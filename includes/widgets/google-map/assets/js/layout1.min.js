"use strict";

(function () {
  'use strict';

  var objectProto$c = Object.prototype;

  var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

  function baseHas(object, key) {
    return object != null && hasOwnProperty$9.call(object, key);
  }

  var _baseHas = baseHas;

  var isArray = Array.isArray;
  var isArray_1 = isArray;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }


  var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal;

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;

  var root = _freeGlobal || freeSelf || Function('return this')();
  var _root = root;

  var _Symbol2 = _root.Symbol;
  var _Symbol = _Symbol2;

  var objectProto$b = Object.prototype;

  var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

  var nativeObjectToString$1 = objectProto$b.toString;

  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  function getRawTag(value) {
    var isOwn = hasOwnProperty$8.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }

    return result;
  }

  var _getRawTag = getRawTag;

  var objectProto$a = Object.prototype;

  var nativeObjectToString = objectProto$a.toString;

  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  var _objectToString = objectToString;

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag && symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  function isObjectLike(value) {
    return value != null && _typeof(value) == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  var symbolTag$1 = '[object Symbol]';

  function isSymbol(value) {
    return _typeof(value) == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag$1;
  }

  var isSymbol_1 = isSymbol;

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }

    var type = _typeof(value);

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol_1(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  var _isKey = isKey;

  function isObject(value) {
    var type = _typeof(value);

    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  var asyncTag = '[object AsyncFunction]',
      funcTag$1 = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  function isFunction(value) {
    if (!isObject_1(value)) {
      return false;
    } 


    var tag = _baseGetTag(value);

    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction;

  var coreJsData = _root['__core-js_shared__'];
  var _coreJsData = coreJsData;

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  var _isMasked = isMasked;

  var funcProto$1 = Function.prototype;

  var funcToString$1 = funcProto$1.toString;

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  var _toSource = toSource;

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  var funcProto = Function.prototype,
      objectProto$9 = Object.prototype;

  var funcToString = funcProto.toString;

  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }

    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;

  function getNative(object, key) {
    var value = _getValue(object, key);

    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  var nativeCreate = _getNative(Object, 'create');

  var _nativeCreate = nativeCreate;

  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;

  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;

  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  var objectProto$8 = Object.prototype;

  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

  function hashGet(key) {
    var data = this.__data__;

    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? undefined : result;
    }

    return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;

  var objectProto$7 = Object.prototype;

  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? data[key] !== undefined : hasOwnProperty$5.call(data, key);
  }

  var _hashHas = hashHas;

  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;

  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } 


  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;
  var _Hash = Hash;

  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;

  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  var eq_1 = eq;

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  var _assocIndexOf = assocIndexOf;

  var arrayProto = Array.prototype;

  var splice = arrayProto.splice;

  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;

  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;

  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  var _listCacheSet = listCacheSet;

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } 


  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;
  var _ListCache = ListCache;

  var Map = _getNative(_root, 'Map');

  var _Map = Map;

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash(),
      'map': new (_Map || _ListCache)(),
      'string': new _Hash()
    };
  }

  var _mapCacheClear = mapCacheClear;

  function isKeyable(value) {
    var type = _typeof(value);

    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  var _isKeyable = isKeyable;

  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  var _getMapData = getMapData;

  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);

    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;

  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;

  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;

  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } 


  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;
  var _MapCache = MapCache;

  var FUNC_ERROR_TEXT = 'Expected a function';

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || _MapCache)();
    return memoized;
  } 


  memoize.Cache = _MapCache;
  var memoize_1 = memoize;

  var MAX_MEMOIZE_SIZE = 500;

  function memoizeCapped(func) {
    var result = memoize_1(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  var reEscapeChar = /\\(\\)?/g;

  var stringToPath = _memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46
    ) {
        result.push('');
      }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });

  var _stringToPath = stringToPath;

  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  var _arrayMap = arrayMap;

  var INFINITY$1 = 1 / 0;

  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }

    if (isArray_1(value)) {
      return _arrayMap(value, baseToString) + '';
    }

    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
  }

  var _baseToString = baseToString;

  function toString(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString;

  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }

    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;

  var argsTag$2 = '[object Arguments]';

  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
  }

  var _baseIsArguments = baseIsArguments;

  var objectProto$6 = Object.prototype;

  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

  var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

  var isArguments = _baseIsArguments(function () {
    return arguments;
  }()) ? _baseIsArguments : function (value) {
    return isObjectLike_1(value) && hasOwnProperty$4.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');
  };
  var isArguments_1 = isArguments;

  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  var reIsUint = /^(?:0|[1-9]\d*)$/;

  function isIndex(value, length) {
    var type = _typeof(value);

    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  var _isIndex = isIndex;

  var MAX_SAFE_INTEGER = 9007199254740991;

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  var isLength_1 = isLength;

  var INFINITY = 1 / 0;

  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  var _toKey = toKey;

  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;

  function has(object, path) {
    return object != null && _hasPath(object, path, _baseHas);
  }

  var has_1 = has;

  function stackClear() {
    this.__data__ = new _ListCache();
    this.size = 0;
  }

  var _stackClear = stackClear;

  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;

  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;

  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;

  var LARGE_ARRAY_SIZE = 200;

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof _ListCache) {
      var pairs = data.__data__;

      if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new _MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;

  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  } 


  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;
  var _Stack = Stack;

  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);

    return this;
  }

  var _setCacheAdd = setCacheAdd;

  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;

  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new _MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  } 


  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;
  var _SetCache = SetCache;

  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  var _arraySome = arraySome;

  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;

  var COMPARE_PARTIAL_FLAG$3 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    } 


    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);

    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new _SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array); 

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      } 


      if (seen) {
        if (!_arraySome(other, function (othValue, othIndex) {
          if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;

  var Uint8Array = _root.Uint8Array;
  var _Uint8Array = Uint8Array;

  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;

  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;

  var COMPARE_PARTIAL_FLAG$2 = 1,
      COMPARE_UNORDERED_FLAG = 2;

  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      mapTag$2 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$2 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag = '[object Symbol]';
  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]';

  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$2:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$1:
        if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag$1:
      case dateTag$1:
      case numberTag$1:
        return eq_1(+object, +other);

      case errorTag$1:
        return object.name == other.name && object.message == other.message;

      case regexpTag$1:
      case stringTag$1:
        return object == other + '';

      case mapTag$2:
        var convert = _mapToArray;

      case setTag$2:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        } 


        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG; 

        stack.set(object, other);

        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);

        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }

    }

    return false;
  }

  var _equalByTag = equalByTag;

  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  var _arrayPush = arrayPush;

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;

  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  var _arrayFilter = arrayFilter;

  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;

  var objectProto$5 = Object.prototype;

  var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

  var nativeGetSymbols = Object.getOwnPropertySymbols;

  var getSymbols = !nativeGetSymbols ? stubArray_1 : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  var _getSymbols = getSymbols;

  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  var _baseTimes = baseTimes;

  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;
  var isBuffer_1 = createCommonjsModule(function (module, exports) {
    var freeExports = exports && !exports.nodeType && exports;

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    var moduleExports = freeModule && freeModule.exports === freeExports;

    var Buffer = moduleExports ? _root.Buffer : undefined;

    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    var isBuffer = nativeIsBuffer || stubFalse_1;
    module.exports = isBuffer;
  });

  var argsTag$1 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag$1 = '[object Map]',
      numberTag = '[object Number]',
      objectTag$2 = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag$1 = '[object Set]',
      stringTag = '[object String]',
      weakMapTag$1 = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;

  function baseIsTypedArray(value) {
    return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;

  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
    var freeExports = exports && !exports.nodeType && exports;

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    var moduleExports = freeModule && freeModule.exports === freeExports;

    var freeProcess = moduleExports && _freeGlobal.process;

    var nodeUtil = function () {
      try {
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } 


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    module.exports = nodeUtil;
  });


  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
  var isTypedArray_1 = isTypedArray;

  var objectProto$4 = Object.prototype;

  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && ( 
      key == 'length' || 
      isBuff && (key == 'offset' || key == 'parent') || 
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || 
      _isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;

  var objectProto$3 = Object.prototype;

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$3;
    return value === proto;
  }

  var _isPrototype = isPrototype;

  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;

  var nativeKeys = _overArg(Object.keys, Object);

  var _nativeKeys = nativeKeys;

  var objectProto$2 = Object.prototype;

  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeys = baseKeys;

  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;

  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;

  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;

  var COMPARE_PARTIAL_FLAG$1 = 1;

  var objectProto$1 = Object.prototype;

  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
        return false;
      }
    } 


    var objStacked = stack.get(object);
    var othStacked = stack.get(other);

    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      } 


      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor; 

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;

  var DataView = _getNative(_root, 'DataView');

  var _DataView = DataView;

  var Promise$1 = _getNative(_root, 'Promise');

  var _Promise = Promise$1;

  var Set = _getNative(_root, 'Set');

  var _Set = Set;

  var WeakMap = _getNative(_root, 'WeakMap');

  var _WeakMap = WeakMap;

  var mapTag = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag = '[object Set]',
      weakMapTag = '[object WeakMap]';
  var dataViewTag = '[object DataView]';

  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);


  var getTag = _baseGetTag; 

  if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag || _Map && getTag(new _Map()) != mapTag || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag || _WeakMap && getTag(new _WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;

          case mapCtorString:
            return mapTag;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag;

          case weakMapCtorString:
            return weakMapTag;
        }
      }

      return result;
    };
  }

  var _getTag = getTag;

  var COMPARE_PARTIAL_FLAG = 1;

  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      objectTag = '[object Object]';

  var objectProto = Object.prototype;

  var hasOwnProperty = objectProto.hasOwnProperty;

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag : _getTag(object),
        othTag = othIsArr ? arrayTag : _getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack());
      return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new _Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new _Stack());
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike_1(value) && !isObjectLike_1(other)) {
      return value !== value && other !== other;
    }

    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;

  function isEqual(value, other) {
    return _baseIsEqual(value, other);
  }

  var isEqual_1 = isEqual;

  (function ($, window) {
    var googleMap = {
      onInit: function onInit() {
        if (!window.google) return;
        console.log(window.elementorModules.frontend.handlers.Base);
        var widgetName = {
          'portuna-addon-google-map.default': googleMap.googleMapInit
        };
        $.each(widgetName, function (widget, callback) {
          window.elementorFrontend.hooks.addAction('frontend/element_ready/' + widget, callback);
        });
      },
      googleMapInit: function googleMapInit($scope) {
        var wrap = $($scope[0]),
            container = wrap.find('.portuna-addon--google-map__container'),
            dataMap = wrap.find('.portuna-addon--google-map--layout1').data('map'),
            zoomLevel = dataMap.zoomLevel,
            centerLat = dataMap.centerLat,
            centerLng = dataMap.centerLng,
            mapStyleTheme = dataMap.mapStyleTheme;
        var coordinates = {
          lat: parseFloat(centerLat || 23.7808875),
          lng: parseFloat(centerLng || 90.2792373)
        },
            mapStyle = decodeURIComponent(mapStyleTheme);
        var options = {
          zoom: parseInt(zoomLevel),
          center: coordinates,
          styles: mapStyle !== '' ? $.parseJSON(mapStyle) : {}
        };
        var map = new google.maps.Map(container[0], options);
        googleMap.markers(map, dataMap);
        googleMap.mapOptions(map, dataMap);
      },
      markers: function markers(map, options) {
        var addressType = options.addressType,
            type = options.type,
            settings = options.multipleMarkers;

        if (type === 'marker') {
          $.each(settings, function (index, options) {
            options.centerLat;
            options.centerLng;
            options.centerLat = options.portuna_marker_lat_multiple;
            options.centerLng = options.portuna_marker_lng_multiple;
            options.markerContent = options.portuna_marker_content_multiple;
            options.popupMaxWidth = options.portuna_marker_content_width;
            options.isPopupOpen = options.portuna_marker_content_opened_switch;
            options.isCustomIcon = options.portuna_marker_icon_switch_multiple;
            options.iconUrl = options.portuna_marker_icon_multiple['url'];
            options.iconWidth = options.portuna_marker_size_width_multiple['size'];
            options.iconHeight = options.portuna_marker_size_height_multiple['size'];
            delete options.portuna_marker_lng_multiple;
            delete options.portuna_marker_lng_multiple;
            delete options.portuna_marker_lat_multiple;
            delete options.portuna_marker_content_multiple;
            delete options.portuna_marker_content_width;
            delete options.portuna_marker_content_opened_switch;
            delete options.portuna_marker_icon_switch_multiple;
            delete options.portuna_marker_icon_multiple;
            delete options.portuna_marker_size_width_multiple;
            delete options.portuna_marker_size_height_multiple;
            var latlng = new google.maps.LatLng(parseFloat(options.centerLat), parseFloat(options.centerLng));
            googleMap.createMarker(map, latlng, options);
          });
        } else {
          var centerLat = options.centerLat,
              centerLng = options.centerLng;

          if (!isEqual_1(addressType, 'address')) {
            var latlng = new google.maps.LatLng(parseFloat(centerLat), parseFloat(centerLng));
            googleMap.createMarker(map, latlng, options);
          } else {
            googleMap.geocoder(map, options);
          }
        }
      },
      geocoder: function geocoder(map, options) {
        var addressName = options.addressName;

        var geocode = function geocode(address) {
          return new Promise(function (resolve, reject) {
            var geocoder = new window.google.maps.Geocoder();
            geocoder.geocode({
              address: address
            }, function (results, status) {
              if (isEqual_1(status, 'OK')) {
                var location = results[0].geometry.location;
                resolve({
                  latlng: location
                });
              } else if (isEqual_1(status, 'ZERO_RESULTS')) {
                reject('The address could not be found.');
              } else {
                reject("Geocode was not successful for the following reason: ".concat(status));
              }
            });
          });
        };

        geocode(addressName).then(function (_ref) {
          var latlng = _ref.latlng;
          googleMap.createMarker(map, latlng, options);
        })["catch"](function (alert) {
          console.log(alert);
        });
      },
      createMarker: function createMarker(map, latlng, options) {
        googleMap.focusOnMarker(map, latlng);
        googleMap.attachMessage(new window.google.maps.Marker({
          map: map,
          position: latlng
        }), options, map);
      },
      attachMessage: function attachMessage(marker, options, map) {
        var markerContent = options.markerContent,
            popupMaxWidth = options.popupMaxWidth,
            isPopupOpen = options.isPopupOpen,
            isCustomIcon = options.isCustomIcon;

        if (!!markerContent) {
          marker.info = new window.google.maps.InfoWindow({
            content: googleMap.createElement('div', {
              'class': 'my-component'
            }, decodeURIComponent(markerContent)).outerHTML,
            maxWidth: popupMaxWidth
          });
        }

        if (isCustomIcon) {
          var iconUrl = options.iconUrl,
              iconWidth = options.iconWidth,
              iconHeight = options.iconHeight;
          marker.setIcon({
            url: iconUrl,
            scaledSize: new window.google.maps.Size(iconWidth, iconHeight)
          });
        }

        if (isPopupOpen && has_1(marker, 'info')) {
          setTimeout(function () {
            return marker.info.open(map, marker);
          }, 1000);
        }

        if (has_1(marker, 'info')) {
          marker.addListener('click', function () {
            return marker.info.open(map, marker);
          });
        }
      },
      focusOnMarker: function focusOnMarker(map, position) {
        map.setCenter(new google.maps.LatLng(position.lat(), position.lng()));
      },
      mapOptions: function mapOptions(map, options) {
        var mapStreetView = options.mapStreetView,
            mapTypeControl = options.mapTypeControl,
            mapZoomControl = options.mapZoomControl,
            mapFullScreen = options.mapFullScreen,
            mapScrollWheel = options.mapScrollWheel;
        map.setOptions({
          streetViewControl: $.parseJSON(mapStreetView),
          mapTypeControl: $.parseJSON(mapTypeControl),
          zoomControl: $.parseJSON(mapZoomControl),
          fullscreenControl: $.parseJSON(mapFullScreen),
          scrollwheel: $.parseJSON(mapScrollWheel)
        });
      },
      createElement: function createElement(type, attributes) {
        var el = document.createElement(type);

        for (var key in attributes) {
          el.setAttribute(key, attributes[key]);
        }

        for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          children[_key - 2] = arguments[_key];
        }

        children.forEach(function (child) {
          if (typeof child === 'string') {
            el.appendChild(document.createTextNode(child));
          } else {
            el.appendChild(child);
          }
        });
        return el;
      },
      onElementChange: function onElementChange(propertyName) {
        console.log(propertyName);
      }
    };
    $(window).on('elementor/frontend/init', googleMap.onInit);
  })(jQuery, window);
})();
