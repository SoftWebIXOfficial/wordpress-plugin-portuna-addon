"use strict";

(function () {
  'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }


  function isObject(value) {
    var type = _typeof(value);

    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;
  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal;

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;

  var root = _freeGlobal || freeSelf || Function('return this')();
  var _root = root;

  var now = function now() {
    return _root.Date.now();
  };

  var now_1 = now;

  var _Symbol2 = _root.Symbol;
  var _Symbol = _Symbol2;

  var objectProto$1 = Object.prototype;

  var hasOwnProperty = objectProto$1.hasOwnProperty;

  var nativeObjectToString$1 = objectProto$1.toString;

  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }

    return result;
  }

  var _getRawTag = getRawTag;

  var objectProto = Object.prototype;

  var nativeObjectToString = objectProto.toString;

  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  var _objectToString = objectToString;

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag && symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  function isObjectLike(value) {
    return value != null && _typeof(value) == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  var symbolTag = '[object Symbol]';

  function isSymbol(value) {
    return _typeof(value) == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag;
  }

  var isSymbol_1 = isSymbol;

  var NAN = 0 / 0;

  var reTrim = /^\s+|\s+$/g;

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  var reIsBinary = /^0b[01]+$/i;

  var reIsOctal = /^0o[0-7]+$/i;

  var freeParseInt = parseInt;

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol_1(value)) {
      return NAN;
    }

    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  var toNumber_1 = toNumber;

  var FUNC_ERROR_TEXT = 'Expected a function';

  var nativeMax = Math.max,
      nativeMin = Math.min;

  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    wait = toNumber_1(wait) || 0;

    if (isObject_1(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      lastInvokeTime = time; 

      timerId = setTimeout(timerExpired, wait); 

      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime; 

      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }

    function timerExpired() {
      var time = now_1();

      if (shouldInvoke(time)) {
        return trailingEdge(time);
      } 


      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined; 

      if (trailing && lastArgs) {
        return invokeFunc(time);
      }

      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }

      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now_1());
    }

    function debounced() {
      var time = now_1(),
          isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }

        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }

      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }

      return result;
    }

    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  var debounce_1 = debounce;

  (function ($, window) {
    var megaMenu = {
      onRegister: function onRegister() {
        var widgetName = {
          'portuna-addon-mega-menu.default': megaMenu.onInit
        };

        if (window.elementorFrontend && window.elementorFrontend.hooks) {
          $.each(widgetName, function (widget, callback) {
            window.elementorFrontend.hooks.addAction('frontend/element_ready/' + widget, callback);
          });
        }
      },
      onInit: function onInit($scope) {
        var $target = $scope,
            instance = null;
        instance = new megaMenuExtensions($target);
        instance.init(instance);
      }
    };

    var megaMenuExtensions = function megaMenuExtensions($scope) {
      var self = this;
      var wrap = $($scope[0]),
          megaMenu = wrap.find('ul.portuna-addon-sub-mega-menu'),
          subMenu = wrap.find('ul.portuna-addon-sub-menu'),
          subMenuInverse = wrap.find('ul.portuna-addon-sub-menu.inverse-side');
      var clearSubMenuPosition = false,
          clearMegaMenuWidth = false;

      self.init = function () {
        var resizerLists = {
          'positionResize': self.megaMenuControlPosition,
          'widthResize': self.megaMenuControlWidth
        };
        self.megaMenuControlBreakpoint();
        $.each(resizerLists, function (resizerList, callback) {
          $(window).on('resize orientationchange', debounce_1(callback, 100));
        });
      };

      self.megaMenuControlPosition = function () {
        var absWidth = $('body').outerWidth(true);

        if (clearSubMenuPosition) {
          subMenuInverse.removeClass('inverse-side');
          clearSubMenuPosition = false;
        }

        if (subMenu[0]) {
          subMenu.each(function () {
            var that = $(this),
                subMenuOffsetLeft = that.offset().left,
                subMenuOffsetRight = subMenuOffsetLeft + that.outerWidth(true),
                subMenuSidePosition = that.closest('.portuna-addon--mega-menu--layout1').hasClass('portuna-addon--mega-menu--layout1-left-side') ? 'left-side' : 'right-side';

            if ('right-side' === subMenuSidePosition) {
              if (subMenuOffsetRight >= absWidth) {
                that.addClass('inverse-side');
                clearSubMenuPosition = true;
              } else if (subMenuOffsetLeft < 0) {
                that.removeClass('inverse-side');
              }
            } else {
              if (subMenuOffsetLeft < 0) {
                that.addClass('inverse-side');
                clearSubMenuPosition = true;
              } else if (subMenuOffsetRight >= absWidth) {
                that.removeClass('inverse-side');
              }
            }
          });
        }
      };

      self.megaMenuControlWidth = function () {
        var absWidth = $('body').outerWidth(true);

        if (clearMegaMenuWidth) {
          megaMenu.css({
            'maxWidth': ''
          });
          clearMegaMenuWidth = false;
        } 


        if (megaMenu[0]) {
          megaMenu.each(function () {
            var that = $(this),
                megaMenuX = that.css('transform').replace(/,/g, '').split(' ')[4] || 0,
                megaMenuOffsetLeft = that.offset().left - megaMenuX,
                megaMenuOffsetRight = megaMenuOffsetLeft + that.outerWidth(true),
                megaMenuSidePosition = that.closest('.portuna-addon--mega-menu--layout1').hasClass('portuna-addon--mega-menu--layout1-left-side') ? 'left-side' : 'right-side';

            if ('right-side' === megaMenuSidePosition) {
              if (megaMenuOffsetRight >= absWidth) {
                that.css({
                  'maxWidth': absWidth - megaMenuOffsetLeft - 5
                });
                clearMegaMenuWidth = true;
              }
            } else {
              if (megaMenuOffsetLeft < 0) {
                that.css({
                  'maxWidth': megaMenuOffsetRight - 5
                });
                clearMegaMenuWidth = true;
              }
            }
          });
        }
      };

      self.megaMenuControlBreakpoint = function () {
        var breakpointChecks = $scope.is('.portuna-addon-breakpoint-menu--custom');

        if (breakpointChecks) {
          console.log('true');
        }
      };

      self.megaMenuControlResponsibility = function () {};
    };

    $(window).on('elementor/frontend/init', megaMenu.onRegister);
  })(jQuery, window);
})();
